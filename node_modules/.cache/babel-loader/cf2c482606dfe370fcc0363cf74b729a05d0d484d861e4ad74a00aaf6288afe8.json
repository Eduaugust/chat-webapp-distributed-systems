{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef, useCallback } from 'react';\nconst useWebSocket = url => {\n  _s();\n  const [receivedMessages, setReceivedMessages] = useState({});\n  const ws = useRef(null);\n  const reconnectTimeout = useRef(null);\n  const connectWebSocket = useCallback(() => {\n    if (ws.current) {\n      ws.current.close();\n    }\n    ws.current = new WebSocket(url);\n    ws.current.onopen = () => {\n      if (reconnectTimeout.current) {\n        clearTimeout(reconnectTimeout.current);\n        reconnectTimeout.current = null;\n      }\n    };\n    ws.current.onmessage = event => {\n      try {\n        const normalizedMessage = event.data.replace(/'/g, '\"');\n        const parsedMessage = JSON.parse(normalizedMessage);\n        if (parsedMessage !== receivedMessages) setReceivedMessages(parsedMessage);\n      } catch (error) {\n        console.error('Error parsing message', error);\n      }\n    };\n    ws.current.onerror = error => {\n      console.error('WebSocket error ');\n      if (!reconnectTimeout.current) {\n        reconnectTimeout.current = setTimeout(() => {\n          connectWebSocket();\n        }, 1000);\n      }\n    };\n    ws.current.onclose = () => {\n      if (!reconnectTimeout.current) {\n        reconnectTimeout.current = setTimeout(() => {\n          connectWebSocket();\n        }, 1000);\n      }\n    };\n  }, [url, receivedMessages]);\n  useEffect(() => {\n    connectWebSocket();\n\n    // Cleanup function to close the WebSocket and clear timeout when the component unmounts\n    return () => {\n      if (ws.current) {\n        ws.current.close();\n      }\n      if (reconnectTimeout.current) {\n        clearTimeout(reconnectTimeout.current);\n      }\n    };\n  }, [connectWebSocket]);\n  const close = useCallback(() => {\n    if (ws.current) {\n      ws.current.close();\n    }\n  }, []);\n  const send = useCallback(message => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      ws.current.send(message);\n    }\n  }, []);\n  const checkConnection = useCallback(() => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      return true;\n    }\n    return false;\n  }, []);\n  return {\n    receivedMessages,\n    send,\n    close,\n    connectWebSocket,\n    checkConnection\n  };\n};\n_s(useWebSocket, \"gDu1vztA3C7FARFy0r1ofZZPh8A=\");\nexport default useWebSocket;","map":{"version":3,"names":["useState","useEffect","useRef","useCallback","useWebSocket","url","_s","receivedMessages","setReceivedMessages","ws","reconnectTimeout","connectWebSocket","current","close","WebSocket","onopen","clearTimeout","onmessage","event","normalizedMessage","data","replace","parsedMessage","JSON","parse","error","console","onerror","setTimeout","onclose","send","message","readyState","OPEN","checkConnection"],"sources":["/home/eduardo/repos/chat/chat-webapp/src/api/index.tsx"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\n\nconst useWebSocket = (url: string) => {\n  const [receivedMessages, setReceivedMessages] = useState({});\n  const ws = useRef<WebSocket | null>(null);\n  const reconnectTimeout = useRef<NodeJS.Timeout | null>(null);\n\n  const connectWebSocket = useCallback(() => {\n    if (ws.current) {\n      ws.current.close();\n    }\n\n    ws.current = new WebSocket(url);\n\n    ws.current.onopen = () => {\n      if (reconnectTimeout.current) {\n        clearTimeout(reconnectTimeout.current);\n        reconnectTimeout.current = null;\n      }\n    };\n\n    ws.current.onmessage = (event) => {\n      try {\n        const normalizedMessage = event.data.replace(/'/g, '\"');\n        const parsedMessage = JSON.parse(normalizedMessage);\n        if (parsedMessage !== receivedMessages)\n          setReceivedMessages(parsedMessage);\n      }\n      catch (error) {\n        console.error('Error parsing message', error);\n      }\n    };\n\n    ws.current.onerror = (error) => {\n      console.error('WebSocket error ');\n      if (!reconnectTimeout.current) {\n        reconnectTimeout.current = setTimeout(() => {\n          connectWebSocket();\n        }, 1000);\n      }\n    };\n\n    ws.current.onclose = () => {\n      if (!reconnectTimeout.current) {\n        reconnectTimeout.current = setTimeout(() => {\n          connectWebSocket();\n        }, 1000);\n      }\n    };\n  }, [url, receivedMessages]);\n\n  useEffect(() => {\n    connectWebSocket();\n\n    // Cleanup function to close the WebSocket and clear timeout when the component unmounts\n    return () => {\n      if (ws.current) {\n        ws.current.close();\n      }\n      if (reconnectTimeout.current) {\n        clearTimeout(reconnectTimeout.current);\n      }\n    };\n  }, [connectWebSocket]);\n\n  const close = useCallback(() => {\n    if (ws.current) {\n      ws.current.close();\n    }\n   \n  }, []);\n\n  const send = useCallback((message: string) => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      ws.current.send(message);\n    }\n  }, []);\n\n  const checkConnection = useCallback(() => {\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n      return true;\n    }\n    return false;\n  }, []);\n\n  \n\n  return {\n    receivedMessages,\n    send,\n    close,\n    connectWebSocket,\n    checkConnection\n  };\n};\n\nexport default useWebSocket;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}